
import math




from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA
import base64
import os
import sys
def main(algorithm):
    
    '''
    key = getRSAKey()

    if algorithm == "DES":
        #processFileDES('fin.txt', 'fout.bin')
        print("\nNot implemented yet\n")
    elif algorithm == "AES":
        processFileAES('fout.txt', 'final.txt')
        print("Done AES Decryption")
        #processFileHybridAES('fout.txt', 'finalText.txt', secret=b"1234567890123456")
    '''


'''
    Reads the RSA Key file (mykey.pem - in DER) generated by cipherModule
    returns an imported key
'''
def getRSAKey(fileName, passphrase=None):
    f = open(fileName, 'rb')
    data = f.read()
    key = RSA.importKey(data,passphrase)
    f.close()
    return key


'''
    Useful method, supports RSA decryption now! : D
'''
def readIV():
    
    fin = 'iv.txt'
    
    processFileRSA(fin, fin)
    
    fin = open('iv.txt', 'rb')
    iv = fin.read()
    
    return iv


'''
    Decrypts the content of a file into an output file
    it offers RSA decryption (PKCS1_OAEP)
'''
def processFileRSA(finName, foutName, key):
    #key = getRSAKey()
    
    fin = open(finName, 'rb')
    
    
    data = fin.read()

    cipher = PKCS1_OAEP.new(key)
    enData = cipher.decrypt(data)
    
    fout = open(foutName, 'wb')
    fout.write(enData)
    
    fin.close()
    fout.close()
    
    
'''
    Decrypts the content of an object and writes it in RAM
    (FOR INTERNAL USAGE ONLY - USE FOR KEYS AND IV'S)
'''
def processObjectRSA(inputObj, key):
    cipher = PKCS1_OAEP.new(key)
    return cipher.decrypt(inputObj)

'''
    Decrypts the content of a file into an output file
    it offers AES Hybrid decryption (AES.MODE_CFB + IV from file + AES key from file + SHA)
    not working though... (missing the SHA part)
'''
def processFileHybridAES(finName, foutName, RSAkey):
    '''
    secretEncodedSize = int( (AES.key_size)[2] / (32/float(44)) )
    ivEncodedSize = int( (AES.key_size)[0] / (16/float(24)) )
    '''
    secretEncodedSize = ivEncodedSize = 344
    
    #open the file for reading and writing
    fin = open(finName, 'rb')
    fout = open(foutName, 'wb')


    #seek to the record position
    fin.seek( (os.path.getsize(finName) - secretEncodedSize - ivEncodedSize) )

    #read the encoded secret and iv from the file
    secret = fin.read( secretEncodedSize )
    iv = fin.read( ivEncodedSize )
    
    #remove the record from the file
    fin.close()
    fin = open(finName, 'a')
    fin.truncate((os.path.getsize(finName) - secretEncodedSize - ivEncodedSize))
    fin.close()
    fin = open(finName, 'rb')
    
    #decode the record
    secret = base64.standard_b64decode(secret)
    iv = base64.standard_b64decode(iv)

    #decipher the secret and the iv
    secret = processObjectRSA(secret, RSAkey)
    iv = processObjectRSA(iv, RSAkey)
    
    
    
    
    #start a new cipher
    cipher = AES.new(secret, AES.MODE_CBC, iv)


    if os.path.getsize(finName) < 32768:
        BLOCK_SIZE = cipher.block_size
        readSize = BLOCK_SIZE * (1.5);

    else:
        BLOCK_SIZE = cipher.block_size * 4096
        readSize = BLOCK_SIZE * (87384/float(65536))
        
    #sizeCounter = 0
    while True:
        '''
        sizeCounter += int(readSize)
        if sizeCounter == os.path.getsize(finName) - secretEncodedSize - ivEncodedSize:
            break
        '''
        data = fin.read(int(readSize))
        
        
        #if len(fin.peek()) == 0: [python 3.x]

        if fin.tell() == os.path.getsize(finName):   
            decoded = base64.standard_b64decode(data)
            
            clearText = cipher.decrypt(decoded)
            clearText = clearText[0:-ord(clearText[-1])]
            fout.write((clearText))
            break
 
        decoded = base64.standard_b64decode(data)

        clearText = cipher.decrypt(decoded)
        
        fout.write((clearText))
    
    fout.close()
    fin.close()


'''
    reads a file based on it's name (name + terminator) and based on a readMode ['r'||'rb']
    returns data in a string or bytearray
'''
def readFile(finName, readMode):
    if finName == '' or finName == None:# or isinstance(finName, str) == False:
        print("\nError in readFile, finName not valid\n")
        return
    if readMode == '' or readMode == None:# or isinstance(readMode, str):
        print("\nError in readFile, writeMode not valid\n")
        return
    
    fin = open(finName, readMode)
    
    data = fin.read()
    
    fin.close()
    return data



'''
    Decrypts the content of a file into an output file
    it offers AES decryption (AES.MODE_CFB + IV from file + AES key from file)

'''
def processFileAES(finName, foutName):
    
    '''
    #get the IV
    iv = readFile('iv.txt', 'rb')

    #get the secret
    #secret = readFile('AESKey.txt', 'rb')
    secret = b"1234567890123456"
    '''
    #open the file for reading and writing
    fin = open(finName, 'rb')
    fout = open(foutName, 'wb')
    
    secret = fin.read( int( (AES.key_size)[2] / (32/float(44)) ) )
    iv = fin.read( int( (AES.key_size)[0] / (16/float(24)) ) )

    secret = base64.standard_b64decode(secret)
    iv = base64.standard_b64decode(iv)

    #start a new cipher
    cipher = AES.new(secret, AES.MODE_CBC, iv)
    

    if os.path.getsize(finName) < 32768:
        BLOCK_SIZE = cipher.block_size
        readSize = BLOCK_SIZE * (1.5);

    else:
        BLOCK_SIZE = cipher.block_size * 4096
        readSize = BLOCK_SIZE * (87384/float(65536))
        
    
    while True:
        
        data = fin.read(int(readSize))
        
        #if len(fin.peek()) == 0: [python 3.x]

        if fin.tell() == os.path.getsize(finName):   
            decoded = base64.standard_b64decode(data)
            
            clearText = cipher.decrypt(decoded)
            clearText = clearText[0:-ord(clearText[-1])]
            fout.write((clearText))
            break
 
        

        decoded = base64.standard_b64decode(data)

        clearText = cipher.decrypt(decoded)
        
        fout.write((clearText))
        
    fout.close()
    fin.close()
