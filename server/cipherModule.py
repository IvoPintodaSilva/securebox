

from Crypto import Random
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.Cipher import DES
from Crypto.PublicKey import RSA
from locale import str
from os.path import os
import base64
import sys
def main(algorithm):
    '''
    generateAndWriteRSAKey()
    
    if algorithm == "DES":
        processFileDES('fin.txt', 'fout.txt')
        print("Done DES Encryption")
    elif algorithm == "AES":
        processFileAES('fin.txt', 'fout.txt')
        print("Done AES Encryption")
    '''

'''
    Specific mode for writing an IV array into a file, it offers RSA encryption
'''
def writeIV(iv):
    if iv == None:
        return
     
    fin = open('iv.txt', 'wb')
    fin.write(iv)
    fin.close()
    
    
    open('auxFile.txt','wb')
     
    processFileRSA('iv.txt', 'auxFile.txt')
    
    fin = open('auxFile.txt', 'rb')
    fout = open('iv.txt', 'wb')
    fout.write(fin.read())
    fout.close()
    fin.close()

    os.remove('auxFile.txt')


'''
    Writes content to a file, it offers no encryption whatsoever
'''
def writeFile(data, finName, writeMode):
    if (data == None) or (data == []):
        print("\nError in writeFile, data not valid\n")
        return
    if finName == '' or finName == None:# or isinstance(finName, str) == False:
        print("\nError in writeFile, finName not valid\n")
        return
    if writeMode == '' or writeMode == None:# or isinstance(writeMode, str):
        print("\nError in writeFile, writeMode not valid\n")
        return
    
    fout = open(finName, writeMode)
    
    if writeMode == 'wb':
        fout.write(data)
    if writeMode == 'w':
        fout.write(str(data))
    
    fout.close()




'''
    Useless method - (needs to re-written to support RSA decryption)
'''
def readIV():
    fin = open('iv.txt', 'rb')
    iv = fin.read()
    return iv


'''
    Decrypts the content of a file into an output file
    it offers AES decryption (AES.MODE_CFB + IV from file + AES key from file)

'''
def processFileHybridAES(finName = None, foutName = None, RSAkey = None):
    if finName == None:
        print 'processFileHybridAES - Missing finName'
        return 
    if foutName == None:
        print 'processFileHybridAES - Missing foutName'
        return
    
    
    #Generate AES key
    secret = os.urandom( (AES.key_size)[2] )
    
    #Generate a new random IV
    iv = os.urandom( (AES.key_size)[0] )
    
    #Start the cipher object
    cipher = AES.new(secret, AES.MODE_CBC, iv)

    fin = open(finName, 'rb')
    fout = open(foutName, 'wb')
    

    if os.path.getsize(finName) < 32768:
        BLOCK_SIZE = cipher.block_size
    else:
        BLOCK_SIZE = cipher.block_size * 4096
        

    while True:

        data = fin.read(BLOCK_SIZE)
        
        if len(data) < BLOCK_SIZE:
            length = BLOCK_SIZE - (len(data) % BLOCK_SIZE)
            
            if length > 255:
                padChar = length % 16
            else:
                padChar = length
            
            pad = ( chr(padChar) )*length 
            
            #data += bytes(pad, encoding='UTF-8') [python 3.x]
            data += pad

            cipherText = cipher.encrypt(data)

            encoded = base64.standard_b64encode(cipherText)

            fout.write(encoded)
            break
        
        
        cipherText = cipher.encrypt(data)
        
        encoded = base64.standard_b64encode(cipherText)
        
        fout.write(encoded)
    

    secret = processObjectRSA(secret, RSAkey)
    secret = base64.standard_b64encode( secret )
    fout.write( secret )
    
    iv = processObjectRSA(iv, RSAkey)
    iv = base64.standard_b64encode( iv )
    fout.write( iv )

    fout.close()
    fin.close()


'''
    Encrypts the content of a file into an output file
    it offers RSA encryption (PKCS1_OAEP)
'''
def processFileRSA(finName, foutName, key):
    
    fin = open(finName, 'rb')
    fout = open(foutName, 'wb')
    
    data = fin.read()

    cipher = PKCS1_OAEP.new(key)
    enData = cipher.encrypt(data)
    

    fout.write(enData)

    fin.close()
    fout.close()




'''
    Encrypts the content of an object and writes it in RAM
    (FOR INTERNAL USAGE ONLY - USE FOR KEYS AND IV'S)
'''
def processObjectRSA(inputObj, key):
    cipher = PKCS1_OAEP.new(key)
    return cipher.encrypt(inputObj)
    
    

'''
    Generates a 2048 bit RSA Key and writes a BYTEARRAY it into a file
    Currently using DER encoding
'''
def generateAndWriteRSAKey(fileName, passphrase=None):
    key = RSA.generate(2048)
    f = open(fileName, 'wb')
    data = key.exportKey('DER',passphrase)
    f.write(bytearray(data))
    f.close()


'''
    Reads the RSA Key file generated by the method above
    returns an imported key
'''
def getRSAKey(fileName, passphrase=None):
    f = open(fileName, 'rb')
    data = f.read()
    key = RSA.importKey(data,passphrase)
    f.close()
    return key


'''
    Encrypts the content of a file into an output file
    it offers AES encryption (AES.MODE_CFB + auto generated IV)
'''
def processFileAES(finName, foutName):
    
    #Generate AES key
    secret = os.urandom( (AES.key_size)[2] )
    
    #Generate a new random IV
    iv = os.urandom( (AES.key_size)[0] )
    
    '''
    #Write the AES key to file named AESKey.txt
    writeFile(secret, 'AESKey.txt', 'wb')

    #Write it to a file named iv.txt
    writeFile(iv, 'iv.txt', 'wb')
    '''
    
    #Start the cipher object
    cipher = AES.new(secret, AES.MODE_CBC, iv)

    fin = open(finName, 'rb')
    fout = open(foutName, 'wb')
    
    fout.write(base64.standard_b64encode(secret))
    fout.write(base64.standard_b64encode(iv))
    

    if os.path.getsize(finName) < 32768:
        BLOCK_SIZE = cipher.block_size
    else:
        BLOCK_SIZE = cipher.block_size * 4096
        

    while True:

        data = fin.read(BLOCK_SIZE)
        
        if len(data) < BLOCK_SIZE:
            length = BLOCK_SIZE - (len(data) % BLOCK_SIZE)
            
            if length > 255:
                padChar = length % 16
            else:
                padChar = length
            
            pad = ( chr(padChar) )*length 
            
            #data += bytes(pad, encoding='UTF-8') [python 3.x]
            data += pad

            cipherText = cipher.encrypt(data)

            encoded = base64.standard_b64encode(cipherText)

            fout.write(encoded)
            break
        
        
        cipherText = cipher.encrypt(data)
        
        encoded = base64.standard_b64encode(cipherText)
        
        fout.write(encoded)
    
    
    fout.close()
    fin.close()




def processFileAESwSecret(finName, foutName, secret, iv):
    
        
    
    '''
    #Write the AES key to file named AESKey.txt
    writeFile(secret, 'AESKey.txt', 'wb')

    #Write it to a file named iv.txt
    writeFile(iv, 'iv.txt', 'wb')
    '''
    
    #Start the cipher object
    cipher = AES.new(secret, AES.MODE_CBC, iv)

    fin = open(finName, 'rb')
    fout = open(foutName, 'wb')
    
    

    if os.path.getsize(finName) < 32768:
        BLOCK_SIZE = cipher.block_size
    else:
        BLOCK_SIZE = cipher.block_size * 4096
        

    while True:

        data = fin.read(BLOCK_SIZE)
        
        if len(data) < BLOCK_SIZE:
            length = BLOCK_SIZE - (len(data) % BLOCK_SIZE)
            
            if length > 255:
                padChar = length % 16
            else:
                padChar = length
            
            pad = ( chr(padChar) )*length 
            
            #data += bytes(pad, encoding='UTF-8') [python 3.x]
            data += pad

            cipherText = cipher.encrypt(data)

            encoded = base64.standard_b64encode(cipherText)

            fout.write(encoded)
            break
        
        
        cipherText = cipher.encrypt(data)
        
        encoded = base64.standard_b64encode(cipherText)
        
        fout.write(encoded)
    
    #fout.write(base64.standard_b64encode(secret))
    #fout.write(base64.standard_b64encode(iv))

    fout.close()
    fin.close()



'''
    Encrypts the content of a file into an output file
    it offers DES encryption (DES.MODE_CFB + static secret)
'''
def processFileDES(finName, foutName):
    secret = b"12345678"
    
    iv = Random.new().read(DES.block_size)
    cipher = DES.new(secret, DES.MODE_CFB, iv)

    fin = open(finName, 'r')
    fout = open(foutName, 'w')

    while True:
        data = fin.read(cipher.block_size)
        fout.write(cipher.encrypt(data))
        if len(data) != cipher.block_size:
            break

    fout.close()
    fin.close()


